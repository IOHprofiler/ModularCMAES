#pragma once

#include "common.hpp"

namespace parameters
{
    struct Modules;
    struct Strategy;
}

namespace sampling
{
    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        [[nodiscard]] virtual Vector operator()() = 0;
        size_t d;

        virtual void reset(const parameters::Modules &, const size_t)
        {
        }
    };

    /**
     * @brief Testing sampler, simple incrementing generator.
     */
    struct Tester : Sampler
    {
        Tester(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override;

    private:
        size_t i = 0;
    };

    /**
     * @brief Random sampling functor
     * @tparam Distribution a random number generator from std::random
     */
    template <typename Distribution = rng::normal<double>>
    struct Random : Sampler
    {

        Random(const size_t d) : Sampler(d), dist{} {}
        Random(const size_t d, const Distribution &dist) : Sampler(d), dist(dist) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            for (auto &xi : x)
                xi = dist(rng::GENERATOR);
            return x;
        }

    private:
        Distribution dist;
    };

    //! Gaussian distribution sampler
    using Gaussian = Random<rng::normal<double>>;

    //! Uniform distribution sampler
    using Uniform = Random<rng::uniform<double>>;

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules& m, const size_t l) override
        {
            sampler->reset(m, l);
            mirror = false;
        }

    private:
        std::shared_ptr<Sampler> sampler;
        Vector previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler.
     * This function orthogonalizes <n_samples>, and successively yields each
     * of them. It uses HouseHolderQR decomposition in order to compute
     * the orthonormalization.
     *
     * Note: result for this thing is not precisely the same as python version
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(n, d), samples(d, n), I(Matrix::Identity(n, d))
        {
        }

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules& mod, const size_t lambda) override;

        static size_t get_n_samples(const parameters::Modules &modules, const size_t lambda);

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Eigen::HouseholderQR<Matrix> qr;
        Matrix samples;
        Matrix I;
        size_t current = 0;
    };



	/**
     * @brief Generator yielding samples from a Halton sequence.
     *
     */
    struct Halton : Sampler
    {
        Halton(const size_t d, const size_t budget);

        [[nodiscard]] Vector operator()() override;

    private:
        rng::Shuffler shuffler;

        std::vector<int> primes;

        static double next(int index, int base);

        static std::pair<int, int> divmod(const double top, const double bottom);

        static std::vector<int> sieve(const int n);
    };

    /**
     * @brief Generator yielding samples from a Sobol sequence.
     *
     */
    struct Sobol : Sampler
    {
        Sobol(const size_t dim);

        [[nodiscard]] Vector operator()() override;

        rng::CachedShuffleSequence cache;
    };

    std::shared_ptr<Sampler> get(const size_t dim, const size_t budget, const parameters::Modules &mod, const size_t lambda);

}
