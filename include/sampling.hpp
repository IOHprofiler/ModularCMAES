#pragma once

#include "common.hpp"

namespace parameters
{
    struct Modules;
    struct Strategy;
}

namespace sampling
{
    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        [[nodiscard]] virtual Vector operator()() = 0;
        size_t d;

        virtual void reset(const parameters::Modules &, const size_t)
        {
        }

        virtual Float expected_length()
        {
            return std::sqrt(static_cast<Float>(d));
        }
    };

    /**
     * @brief Testing sampler, simple incrementing generator.
     */
    struct Tester : Sampler
    {
        Tester(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override;

    private:
        size_t i = 0;
    };

    /**
     * @brief Random sampling functor
     * @tparam Distribution a random number generator from std::random
     */
    template <typename Distribution = rng::normal<Float>>
    struct Random : Sampler
    {

        Random(const size_t d) : Sampler(d), dist{} {}
        Random(const size_t d, const Distribution &dist) : Sampler(d), dist(dist) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            for (auto &xi : x)
                xi = dist(rng::GENERATOR);
            return x;
        }

    private:
        Distribution dist;
    };

    // //! Gaussian distribution sampler
    using Gaussian = Random<rng::normal<Float>>;

    //! Uniform distribution sampler
    using Uniform = Random<rng::uniform<Float>>;

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules &m, const size_t l) override
        {
            sampler->reset(m, l);
            mirror = false;
        }

    private:
        std::shared_ptr<Sampler> sampler;
        Vector previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler.
     * This function orthogonalizes <n_samples>, and successively yields each
     * of them. It uses HouseHolderQR decomposition in order to compute
     * the orthonormalization.
     *
     * Note: result for this thing is not precisely the same as python version
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(n, d), samples(d, n), I(Matrix::Identity(n, d))
        {
        }

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules &mod, const size_t lambda) override;

        static size_t get_n_samples(const parameters::Modules &modules, const size_t lambda);

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Eigen::HouseholderQR<Matrix> qr;
        Matrix samples;
        Matrix I;
        size_t current = 0;
    };

    /**
     * @brief Generator yielding samples from a Halton sequence.
     *
     */
    struct Halton : Sampler
    {
        Halton(const size_t d, const bool scramble = true);

        [[nodiscard]] Vector operator()() override;

    private:
        int index_;
        bool scramble_;
        std::vector<int> primes_;
        std::vector<std::vector<std::vector<int>>> permutations_;

        static Float next(int index, const int base);

        static Float next(int index, const int base, const std::vector<std::vector<int>> &permutations);

        static std::vector<int> sieve(const int n);

        static std::vector<std::vector<std::vector<int>>> get_permutations(const std::vector<int> &primes);

        static std::vector<int> n_primes(const size_t d);
    };

    /**
     * @brief Generator yielding samples from a Sobol sequence.
     *
     */
    struct Sobol : Sampler
    {
        rng::CachedShuffleSequence cache;

        Sobol(const size_t dim);

        [[nodiscard]] Vector operator()() override { return cache.next(); }
    };

    /**
     * \brief A sampler that cycles through a number of points in a cache
     */
    struct CachedSampler : Sampler
    {
        std::shared_ptr<Sampler> sampler;
        std::vector<Vector> cache;
        size_t index;
        size_t n_samples;

        CachedSampler(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d),
                                                                sampler(sampler),
                                                                cache(),
                                                                index(0),
                                                                n_samples(std::max(constants::cache_min_samples, utils::nearest_power_of_2(constants::cache_max_doubles / sampler->d)))
        {
            cache.reserve(n_samples);
        }

        CachedSampler(const std::vector<Vector> &cache, const bool transform_ppf = false)
            : Sampler(cache[0].size()),
              sampler(std::make_shared<Tester>(cache[0].size())),
              cache(cache),
              index(cache.size()),
              n_samples(cache.size())
        {
            if (transform_ppf)
                for (auto &sample : this->cache)
                    for (auto &si : sample)
                        si = ppf(si);
        }

        [[nodiscard]] Vector operator()() override
        {
            Vector sample;
            if (index < n_samples)
                cache.emplace_back(sampler->operator()());

            return cache[index++ % n_samples];
        }
    };

    /***
     * \brief Abstract class for sample transformation methods
     */
    struct SampleTransformer : Sampler
    {

        SampleTransformer(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}
        /**
         * Should be overwritten, transforms U(0,1) indep samples into something else
         */
        [[nodiscard]] virtual Vector transform(Vector x) = 0;

        [[nodiscard]] virtual Vector operator()() override
        {
            return transform((*sampler)());
        }

        void reset(const parameters::Modules &m, const size_t l) override
        {
            sampler->reset(m, l);
        }

        [[nodiscard]] Vector raw()
        {
            return (*sampler)();
        }

    protected:
        std::shared_ptr<Sampler> sampler;
    };

    struct IdentityTransformer: SampleTransformer
    {
        IdentityTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}
        
        [[nodiscard]] virtual Vector transform(Vector x)
        {
            return x;
        }
    };


    //! Adds ppf to transform into gaussian
    struct GaussianTransformer : SampleTransformer
    {
        GaussianTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        Float expected_length() override
        {
            const Float dd = static_cast<Float>(this->sampler->d);
            return sqrt(dd) * (1.0 - 1.0 / (4.0 * dd) + 1.0 / (21.0 * pow(dd, 2.0)));
        }

        [[nodiscard]] virtual Vector transform(Vector x) override
        {
            for (auto &xi : x)
                xi = ppf(xi);
            return x;
        }
    };

    struct UniformScaler : SampleTransformer
    {
        static inline Float scale = std::sqrt(3.0);

        UniformScaler(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(Vector x) override
        {
            for (auto &xi : x)
                xi = -scale + (2.0 * scale) * xi;
            return x;
        }
    };

    struct LaplaceTransformer : SampleTransformer
    {
        static inline Float b = std::sqrt(0.5);
        
        LaplaceTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(Vector x) override
        {
            for (auto &xi : x)
            {
                if (xi < 0.5)
                    xi = b * std::log(2.0 * xi);
                else
                    xi = -b * std::log(2.0 * (1.0 - xi));
                
            }
            return x;
        }
    };

    struct LogisticTransformer : SampleTransformer
    {
        static inline Float s = std::sqrt(3.0) / M_PI;
        
        LogisticTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(Vector x) override
        {
            for (auto &xi : x)
                xi = s * std::log(xi  / (1 - xi));
            return x;
        }
    };

    struct CauchyTransformer : SampleTransformer
    {
        static inline Float gamma = 1.0;

        CauchyTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}


        Float expected_length() override
        {
            // TODO: this should be something like 1.18 * n
            // Expectation is undef, we can use median? 
            const Float dd = static_cast<Float>(this->sampler->d);
            // Empirically approximated median
            const Float median_z = dd * (1.0 + 0.18 * std::tanh(dd / 4.07));
            return median_z;
        }

        [[nodiscard]] virtual Vector transform(Vector x) override
        {
            for (auto &xi : x)
                xi = gamma * std::tan(M_PI * (xi - 0.5));
            return x;
        }
    };

    struct DoubleWeibullTransformer : SampleTransformer
    {
        DoubleWeibullTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(Vector x) override
        {
            for (auto &xi : x)
                if (xi < 0.5)
                    xi = -std::sqrt(-std::log(2.0 * xi));
                else
                    xi = std::sqrt(-std::log(2.0 * (1.0 - xi)));
            return x;
        }
    };



    std::shared_ptr<Sampler> get(const size_t dim, const parameters::Modules &mod, const size_t lambda);

}
