#pragma once

#include "common.hpp"

namespace parameters
{
    struct Modules;
    struct Strategy;
}

namespace sampling
{
    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        size_t d;
        
        virtual void reset(const parameters::Modules &, const size_t)
        {
        }
        
        virtual Float expected_length()
        {
            return std::sqrt(static_cast<Float>(d));
        }
        [[nodiscard]] virtual Vector operator()() = 0;
    };

    /**
     * @brief Testing sampler, simple incrementing generator.
     */
    struct Tester : Sampler 
    {
        Tester(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override;

    private:
        size_t i = 0;
    };

    /**
     * @brief Random sampling functor
     * @tparam Distribution a random number generator from std::random
     */
    template <typename Distribution = rng::normal<Float>>
    struct Random : Sampler
    {

        Random(const size_t d) : Sampler(d), dist{} {}
        Random(const size_t d, const Distribution &dist) : Sampler(d), dist(dist) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            for (auto &xi : x)
                xi = dist(rng::GENERATOR);
            return x;
        }

    private:
        Distribution dist;
    };

    // //! Gaussian distribution sampler
    using Gaussian = Random<rng::normal<Float>>;

    //! Uniform distribution sampler
    using Uniform = Random<rng::uniform<Float>>;

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules &m, const size_t l) override
        {
            sampler->reset(m, l);
            mirror = false;
        }

    private:
        std::shared_ptr<Sampler> sampler;
        Vector previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler.
     * This function orthogonalizes <n_samples>, and successively yields each
     * of them. It uses HouseHolderQR decomposition in order to compute
     * the orthonormalization.
     *
     * Note: result for this thing is not precisely the same as python version
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(n, d), samples(d, n), I(Matrix::Identity(n, d))
        {
        }

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules &mod, const size_t lambda) override;

        static size_t get_n_samples(const parameters::Modules &modules, const size_t lambda);

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Eigen::HouseholderQR<Matrix> qr;
        Matrix samples;
        Matrix I;
        size_t current = 0;
    };

    /**
     * @brief Generator yielding samples from a Halton sequence.
     *
     */
    struct Halton : Sampler
    {
        Halton(const size_t d, const bool scramble = true);

        [[nodiscard]] Vector operator()() override;

    private:
        int index_;
        bool scramble_;
        std::vector<int> primes_;
        std::vector<std::vector<std::vector<int>>> permutations_;

        static Float next(int index, const int base);

        static Float next(int index, const int base, const std::vector<std::vector<int>> &permutations);

        static std::vector<int> sieve(const int n);

        static std::vector<std::vector<std::vector<int>>> get_permutations(const std::vector<int> &primes);

        static std::vector<int> n_primes(const size_t d);
    };

    /**
     * @brief Generator yielding samples from a Sobol sequence.
     *
     */
    struct Sobol : Sampler
    {
        rng::CachedShuffleSequence cache;

        Sobol(const size_t dim);

        [[nodiscard]] Vector operator()() override { return cache.next(); }
    };

    /**
     * \brief A sampler that cycles through a number of points in a cache
     */
    struct CachedSampler : Sampler
    {
        std::shared_ptr<Sampler> sampler;
        std::vector<Vector> cache;
        size_t index;
        size_t n_samples;

        CachedSampler(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d),
                                                                sampler(sampler),
                                                                cache(),
                                                                index(0),
                                                                n_samples(std::max(constants::cache_min_samples, utils::nearest_power_of_2(constants::cache_max_doubles / sampler->d)))
        {
            cache.reserve(n_samples);
        }

        CachedSampler(const std::vector<Vector> &cache, const bool transform_ppf = false)
            : Sampler(cache[0].size()),
              sampler(std::make_shared<Tester>(cache[0].size())),
              cache(cache),
              index(cache.size()),
              n_samples(cache.size())
        {
            if (transform_ppf)
                for (auto &sample : this->cache)
                    for (auto &si : sample)
                        si = ppf(si);
        }

        [[nodiscard]] Vector operator()() override
        {
            Vector sample;
            if (index < n_samples)
                cache.emplace_back(sampler->operator()());

            return cache[index++ % n_samples];
        }
    };

    /***
     * \brief Abstract class for sample transformation methods
     */
    struct SampleTransformer : Sampler
    {

        SampleTransformer(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}
        /**
         * Should be overwritten, transforms U(0,1) indep samples into something else
         */
        [[nodiscard]] virtual Vector transform(const Vector& x) = 0;

        [[nodiscard]] virtual Vector operator()() override
        {
            return transform((*sampler)());
        }

        void reset(const parameters::Modules &m, const size_t l) override
        {
            sampler->reset(m, l);
        }

        [[nodiscard]] Vector raw()
        {
            return (*sampler)();
        }

        std::shared_ptr<Sampler> sampler;
    };

    struct IdentityTransformer: SampleTransformer
    {
        IdentityTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}
        
        [[nodiscard]] virtual Vector transform(const Vector& x)
        {
            return x;
        }
    };


    //! Adds ppf to transform into gaussian
    struct GaussianTransformer : SampleTransformer
    {
        GaussianTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        Float expected_length() override
        {
            const Float dd = static_cast<Float>(this->sampler->d);
            return sqrt(dd) * (1.0 - 1.0 / (4.0 * dd) + 1.0 / (21.0 * pow(dd, 2.0)));
        }

        [[nodiscard]] inline std::pair<Float, Float> box_muller(const Float u1, const Float u2)
        {
            const Float r = std::sqrt(-2.0 * std::log(u1));
            const Float theta = 2.0 * M_PI * u2;
            return { r * std::cos(theta), r * std::sin(theta) };
        }


        [[nodiscard]] inline Vector box_muller(const Vector& u)
        {
            static Vector u_extra;
            static int n_extra_used = 0;
            static bool needs_new_sample = true;
            static Float extra_sample;

            size_t n = u.size();
            size_t m = n / 2;

            Vector z(n);
            for (size_t i = 0; i < m; ++i) {
                const auto&[n1, n2] = box_muller(u(2 * i), u(2 * i + 1));
                z(2 * i) = n1;
                z(2 * i + 1) = n2;
            }

            if (n % 2 != 0)
            {
                if (u_extra.size() <= n_extra_used)
                {
                    u_extra = (*sampler)();
                    n_extra_used = 0;
                }

                if (needs_new_sample)
                {
                    const auto&[n1, n2] = box_muller(u(n - 1), u_extra(n_extra_used++));
                    z(n - 1) = n1;
                    extra_sample = n2;
                    needs_new_sample = false;                 
                }
                else
                {
                    z(n -1) = extra_sample;
                    needs_new_sample = true;
                }
            }

            return z;
        }   


        [[nodiscard]] virtual Vector transform(const Vector& x) override
        {
            if (constants::use_box_muller)
                return box_muller(x);
            return x.unaryExpr(&ppf);
        }
    };

    struct UniformScaler : SampleTransformer
    {
        static inline Float scale = std::sqrt(3.0);

        UniformScaler(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(const Vector& x) override
        {
            return (-scale + (2.0 * scale) * x.array()).matrix();
        }
    };

    struct LaplaceTransformer : SampleTransformer
    {
        static inline Float b = std::sqrt(0.5);
        
        LaplaceTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(const Vector& x) override
        {
            return ((x.array() < 0.5)
                .select(b * (2.0 * x.array()).log(),
                    -b * (2.0 * (1.0 - x.array())).log())).matrix();
        }
    };

    struct LogisticTransformer : SampleTransformer
    {
        static inline Float s = std::sqrt(3.0) / M_PI;
        
        LogisticTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(const Vector& x) override
        {
            return (s * (x.array() / (1.0 - x.array())).log()).matrix();
        }
    };

    struct CauchyTransformer : SampleTransformer
    {
        static inline Float gamma = 1.0;

        CauchyTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}


        Float expected_length() override
        {
            // TODO: this should be something like 1.18 * n
            // Expectation is undef, we can use median? 
            const Float dd = static_cast<Float>(this->sampler->d);
            // Empirically approximated median
            const Float median_z = dd * (1.0 + 0.18 * std::tanh(dd / 4.07));
            return median_z;
        }

        [[nodiscard]] virtual Vector transform(const Vector& x) override
        {
            return (gamma * (M_PI * (x.array() - 0.5)).tan()).matrix();
        }
    };

    struct DoubleWeibullTransformer : SampleTransformer
    {
        DoubleWeibullTransformer(const std::shared_ptr<Sampler> sampler) : SampleTransformer(sampler) {}

        [[nodiscard]] virtual Vector transform(const Vector& x) override
        {
            return ((x.array() < 0.5)
                .select(
                    -(-((2.0 * x.array()).log())).sqrt(),
                    (-((2.0 * (1.0 - x.array())).log())).sqrt()
                )).matrix();
        }
    };



    std::shared_ptr<Sampler> get(const size_t dim, const parameters::Modules &mod, const size_t lambda);

}
