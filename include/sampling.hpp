#pragma once

#include "common.hpp"

/**
 * @brief Percent point function (inverse of cdf) of a standard normal distribution.
 *
 * see: ndtri.cpp
 * @param x lower tail of the probabilty
 * @return double quantile corresponding to the lower tail probability q
 */
double ppf(const double x);

/**
 * @brief Generate a sobol sequence using 8 byte integer numbers.
 * see: sobol.cpp
 *
 * @param dim_num  The dimension of the generated vector
 * @param seed The current seed of the sobol sequence
 * @param quasi the vector of random numbers in which to place the output
 */
void i8_sobol(int dim_num, long long int *seed, double quasi[]);

namespace parameters
{
    struct Modules;
    struct Strategy;
}

namespace sampling
{
    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        [[nodiscard]] virtual Vector operator()() = 0;
        size_t d;
    };

    /**
     * @brief Testing sampler, simple incrementing generator.
     */
    struct Tester : Sampler
    {
        Tester(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override;

    private:
        size_t i = 0;
    };

    /**
     * @brief Random sampling functor
     * @tparam Distribution a random number generator from std::random
     */
    template <typename Distribution = rng::normal<double>>
    struct Random : Sampler
    {

        Random(const size_t d) : Sampler(d), dist{} {}
        Random(const size_t d, const Distribution &dist) : Sampler(d), dist(dist) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            for (auto &xi : x)
                xi = dist(rng::GENERATOR);
            return x;
        }

    private:
        Distribution dist;
    };

    //! Gaussian distribution sampler
    using Gaussian = Random<rng::normal<double>>;

    //! Uniform distribution sampler
    using Uniform = Random<rng::uniform<double>>;

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}

        [[nodiscard]] Vector operator()() override;

    private:
        std::shared_ptr<Sampler> sampler;
        Vector previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler.
     * This function orthogonalizes <n_samples>, and succesively yields each
     * of them. It uses HouseHolderQR decomposition in order to compute
     * the orthonomalization.
     *
     * Note: result for this thing is not precisly the same as python version
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(n, d), samples(d, n), I(Matrix::Identity(n, d))
        {
        }

        [[nodiscard]] Vector operator()() override;

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Eigen::HouseholderQR<Matrix> qr;
        Matrix samples;
        Matrix I;
        size_t current = 0;
    };

    /**
     * @brief Generator yielding samples from a Halton sequence.
     *
     */
    struct Halton : Sampler
    {
        Halton(const size_t d, const size_t i = 1);

        [[nodiscard]] Vector operator()() override;

    private:
        size_t i;
        std::vector<int> primes;

        static double next(int index, int base);

        static std::pair<int, int> divmod(const double top, const double bottom);

        static std::vector<int> sieve(const int n);
    };

    /**
     * @brief Generator yielding samples from a Sobol sequence.
     *
     */
    struct Sobol : Sampler
    {
        Sobol(const size_t d) : Sampler(d), seed(rng::random_integer(2, std::max(3, static_cast<int>(d * d))))
        {
        }

        [[nodiscard]] Vector operator()() override;

    private:
        long long seed;
    };



    std::shared_ptr<Sampler> get(const size_t dim, const parameters::Modules &mod, const size_t lambda);

}
