#pragma once

#include "common.hpp"

namespace parameters
{
    struct Modules;
    struct Strategy;
}

namespace sampling
{
    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        [[nodiscard]] virtual Vector operator()() = 0;
        size_t d;

        virtual void reset(const parameters::Modules &, const size_t)
        {
        }
    };

    /**
     * @brief Testing sampler, simple incrementing generator.
     */
    struct Tester : Sampler
    {
        Tester(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override;

    private:
        size_t i = 0;
    };

    /**
     * @brief Random sampling functor
     * @tparam Distribution a random number generator from std::random
     */
    template <typename Distribution = rng::normal<double>>
    struct Random : Sampler
    {

        Random(const size_t d) : Sampler(d), dist{} {}
        Random(const size_t d, const Distribution &dist) : Sampler(d), dist(dist) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            for (auto &xi : x)
                xi = dist(rng::GENERATOR);
            return x;
        }

    private:
        Distribution dist;
    };

    //! Gaussian distribution sampler
    using Gaussian = Random<rng::normal<double>>;

    //! Uniform distribution sampler
    using Uniform = Random<rng::uniform<double>>;

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> sampler) : Sampler(sampler->d), sampler(sampler) {}

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules& m, const size_t l) override
        {
            sampler->reset(m, l);
            mirror = false;
        }

    private:
        std::shared_ptr<Sampler> sampler;
        Vector previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler.
     * This function orthogonalizes <n_samples>, and successively yields each
     * of them. It uses HouseHolderQR decomposition in order to compute
     * the orthonormalization.
     *
     * Note: result for this thing is not precisely the same as python version
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(n, d), samples(d, n), I(Matrix::Identity(n, d))
        {
        }

        [[nodiscard]] Vector operator()() override;

        void reset(const parameters::Modules& mod, const size_t lambda) override;

        static size_t get_n_samples(const parameters::Modules &modules, const size_t lambda);

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Eigen::HouseholderQR<Matrix> qr;
        Matrix samples;
        Matrix I;
        size_t current = 0;
    };
   

	/**
     * @brief Generator yielding samples from a Halton sequence.
     *
     */
    struct Halton : Sampler
    {
        Halton(const size_t d, const bool scramble = true);

        [[nodiscard]] Vector operator()() override;

    private:
        int index_;
        bool scramble_;
    	std::vector<int> primes_;
        std::vector<std::vector<std::vector<int>>> permutations_;

        static double next(int index, const int base);

        static double next(int index, const int base, const std::vector<std::vector<int>>& permutations);

        static std::vector<int> sieve(const int n);

        static std::vector<std::vector<std::vector<int>>> get_permutations(const std::vector<int>& primes);

        static std::vector<int> n_primes(const size_t d);
      
    };

   
    /**
     * @brief Generator yielding samples from a Sobol sequence.
     *
     */
    struct Sobol : Sampler
    {
        rng::CachedShuffleSequence cache;
     
        Sobol(const size_t dim);

        [[nodiscard]] Vector operator()() override { return cache.next(); }
    };


    /**
     * \brief A sampler that cycles through a number of points in a cache
     */
    struct CachedSampler: Sampler
    {
        std::shared_ptr<Sampler> sampler;
        std::vector<Vector> cache;
        size_t index;
        size_t n_samples;
        
        CachedSampler(const std::shared_ptr<Sampler> sampler): 
            Sampler(sampler->d), 
            sampler(sampler),
            cache(),
            index(0),
            n_samples(std::max(constants::cache_min_samples, utils::nearest_power_of_2(constants::cache_max_doubles / sampler->d)))
        { 
            cache.reserve(n_samples);
        }

        CachedSampler(const std::vector<Vector>& cache, const bool transform_ppf = false)
            : Sampler(cache[0].size()),
              sampler(std::make_shared<Tester>(cache[0].size())),
              cache(cache),
              index(cache.size()),
              n_samples(cache.size())
        {
            if (transform_ppf)
                for (auto& sample: this->cache)
                    for (auto& si: sample)
                        si = ppf(si);
        }


        [[nodiscard]] Vector operator()() override { 
            Vector sample;
            if (index < n_samples)
                cache.emplace_back(sampler->operator()());
            
            return cache[index++ % n_samples];
        }
    };


    std::shared_ptr<Sampler> get(const size_t dim, const parameters::Modules &mod, const size_t lambda);

}
