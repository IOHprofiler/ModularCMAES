import numpy
from typing import Callable

class BIPOP(Strategy):
    budget: int
    budget_large: int
    budget_small: int
    lambda_init: int
    lambda_large: int
    lambda_small: int
    mu_factor: float
    def __init__(self, sigma: float, dimension: float, lamb: float, mu: float, budget: int) -> None: ...
    def large(self) -> bool: ...
    def restart(self, objective: Callable[[numpy.ndarray], float], parameters) -> None: ...
    @property
    def used_budget(self) -> int: ...

class IPOP(Strategy):
    ipop_factor: float
    def __init__(self, sigma: float, dimension: float, lamb: float) -> None: ...
    def restart(self, objective: Callable[[numpy.ndarray], float], parameters) -> None: ...

class NoRestart(Strategy):
    def __init__(self, sigma: float, dimension: float, lamb: float) -> None: ...
    def restart(self, objective: Callable[[numpy.ndarray], float], parameters) -> None: ...

class Restart(Strategy):
    def __init__(self, sigma: float, dimension: float, lamb: float) -> None: ...
    def restart(self, objective: Callable[[numpy.ndarray], float], parameters) -> None: ...

class RestartCriteria:
    def __init__(self, sigma: float, dimension: float, lamb: float, time: int) -> None: ...
    def conditioncov(self) -> bool: ...
    def exceeded_max_iter(self) -> bool: ...
    def flat_fitness(self) -> bool: ...
    def no_improvement(self) -> bool: ...
    def noeffectaxis(self) -> bool: ...
    def noeffectcoor(self) -> bool: ...
    def stagnation(self) -> bool: ...
    def tolupsigma(self) -> bool: ...
    def tolx(self) -> bool: ...
    def __call__(self, parameters) -> bool: ...
    @property
    def any(self) -> bool: ...
    @property
    def best_fitnesses(self) -> list[float]: ...
    @property
    def condition_c(self) -> float: ...
    @property
    def d_sigma(self) -> float: ...
    @property
    def effect_axis(self) -> numpy.ndarray: ...
    @property
    def effect_coord(self) -> numpy.ndarray: ...
    @property
    def flat_fitness_index(self) -> int: ...
    @property
    def flat_fitnesses(self) -> numpy.ndarray[numpy.int32[m, 1]]: ...
    @property
    def last_restart(self) -> int: ...
    @property
    def max_iter(self) -> int: ...
    @property
    def median_fitnesses(self) -> list[float]: ...
    @property
    def n_bin(self) -> int: ...
    @property
    def n_flat_fitness(self) -> int: ...
    @property
    def n_stagnation(self) -> int: ...
    @property
    def recent_improvement(self) -> float: ...
    @property
    def root_max_d(self) -> float: ...
    @property
    def sigma0(self) -> float: ...
    @property
    def time_since_restart(self) -> int: ...
    @property
    def tolx_condition(self) -> float: ...
    @property
    def tolx_vector(self) -> numpy.ndarray: ...

class Stop(Strategy):
    def __init__(self, sigma: float, dimension: float, lamb: float) -> None: ...
    def restart(self, objective: Callable[[numpy.ndarray], float], parameters) -> None: ...

class Strategy:
    criteria: RestartCriteria
    def __init__(self, *args, **kwargs) -> None: ...
    def evaluate(self, objective: Callable[[numpy.ndarray], float], parameters) -> None: ...
