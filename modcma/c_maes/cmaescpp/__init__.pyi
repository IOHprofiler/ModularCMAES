from typing import Any, Callable, List, Optional

from typing import overload
import numpy

from . import parameters, sampling, mutation, bounds

class ModularCMAES:
    def __init__(self, parameters: Parameters) -> None: ...
    def break_conditions(self) -> bool: ...
    def recombine(self) -> None: ...
    def step(
        self, objective: Callable[[numpy.ndarray[numpy.float64[m, 1]]], float]
    ) -> bool: ...
    def __call__(
        self, objective: Callable[[numpy.ndarray[numpy.float64[m, 1]]], float]
    ) -> None: ...
    @property
    def parameters(self) -> Parameters: ...

class Parameters:
    @overload
    def __init__(self, dimension: int) -> None: ...
    @overload
    def __init__(self, dimension: int, modules: parameters.Modules) -> None: ...
    def adapt(self) -> None: ...
    def perform_restart(self, sigma: Optional[float] = ...) -> None: ...
    @property
    def dim(self) -> int: ...
    @property
    def mu(self) -> int: ...
    @property
    def lamb(self) -> int: ...
    @property
    def modules(self) -> parameters.Modules: ...
    @property
    def dynamic(self) -> parameters.Dynamic: ...
    @property
    def mutation(self) -> mutation.Strategy: ...
    @property
    def old_pop(self) -> Population: ...
    @property
    def pop(self) -> Population: ...
    @property
    def restart(self) -> restart.Strategy: ...
    @property
    def sampler(self) -> sampling.Sampler: ...
    @property
    def selection(self) -> Any: ...
    @property
    def stats(self) -> parameters.Stats: ...
    @property
    def weights(self) -> parameters.Weights: ...
    @property
    def bounds(self) -> bounds.BoundCorrection: ...
    verbose: bool

class Population:
    X: numpy.ndarray[numpy.float64[m, n]]
    Y: numpy.ndarray[numpy.float64[m, n]]
    Z: numpy.ndarray[numpy.float64[m, n]]
    d: int
    f: numpy.ndarray[numpy.float64[m, 1]]
    n: int
    s: numpy.ndarray[numpy.float64[m, 1]]
    def __init__(self, dimension: int, n: int) -> None: ...
    def keep_only(self, idx: List[int]) -> None: ...
    def resize_cols(self, size: int) -> None: ...
    def sort(self) -> None: ...
    def __add__(self, other: Population) -> None: ...
    @property
    def n_finite(self) -> int: ...
