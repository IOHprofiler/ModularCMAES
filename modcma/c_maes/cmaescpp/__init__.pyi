from typing import Any, Callable, List, Optional

from typing import overload
import numpy
from . import parameters, sampling, mutation, restart

class Population:
    X: numpy.ndarray
    Y: numpy.ndarray
    Z: numpy.ndarray
    d: int
    f: numpy.ndarray
    n: int
    s: numpy.ndarray
    @overload
    def __init__(self, dimension: int, n: int) -> None: ...
    @overload
    def __init__(self, X: numpy.ndarray, Z: numpy.ndarray, Y: numpy.ndarray, f: numpy.ndarray, s: numpy.ndarray) -> None: ...
    def keep_only(self, idx: List[int]) -> None: ...
    def resize_cols(self, size: int) -> None: ...
    def sort(self) -> None: ...
    def __add__(self, other: Population) -> None: ...
    @property
    def n_finite(self) -> int: ...

class Parameters:
    bounds: Any
    dynamic: parameters.Dynamic
    lamb: int
    mu: int
    mutation: mutation.Strategy
    old_pop: Population
    pop: Population
    restart: restart.Strategy
    sampler: sampling.Sampler
    selection: Any
    settings: parameters.Settings
    stats: parameters.Stats
    weights: parameters.Weights
    @overload
    def __init__(self, dimension: int) -> None: ...
    @overload
    def __init__(self, settings: parameters.Settings) -> None: ...
    def adapt(self) -> None: ...
    def perform_restart(self, sigma: Optional[float] = ...) -> None: ...

class ModularCMAES:
    def __init__(self, parameters: Parameters) -> None: ...
    def adapt(self) -> None: ...
    def break_conditions(self) -> bool: ...
    def mutate(
        self, arg0: Callable[[numpy.ndarray], float]
    ) -> None: ...
    def recombine(self) -> None: ...
    def select(self) -> None: ...
    def step(
        self, objective: Callable[[numpy.ndarray], float]
    ) -> bool: ...
    def __call__(
        self, objective: Callable[[numpy.ndarray], float]
    ) -> None: ...
    @property
    def p(self) -> Parameters: ...
