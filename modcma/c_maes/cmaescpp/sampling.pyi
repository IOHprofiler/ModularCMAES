import modcma.c_maes.cmaescpp.utils
import numpy
from typing import Callable, overload

class CachedSampler(Sampler):
    @overload
    def __init__(self, sampler: Sampler) -> None: ...
    @overload
    def __init__(self, cache: list[numpy.ndarray]) -> None: ...
    def __call__(self) -> numpy.ndarray: ...
    @property
    def cache(self) -> list[numpy.ndarray]: ...
    @property
    def index(self) -> int: ...
    @property
    def n_samples(self) -> int: ...

class Gaussian(Sampler):
    def __init__(self, d: int) -> None: ...
    def __call__(self) -> numpy.ndarray: ...

class Halton(Sampler):
    def __init__(self, d: int, scrambled: bool = True) -> None: ...
    def __call__(self) -> numpy.ndarray: ...

class Mirrored(Sampler):
    def __init__(self, sampler: Sampler) -> None: ...
    def __call__(self) -> numpy.ndarray: ...

class Orthogonal(Sampler):
    def __init__(self, sampler: Sampler, n_samples: int) -> None: ...
    def __call__(self) -> numpy.ndarray: ...

class PySampler(Sampler):
    def __init__(self, d: int, function: Callable[[], float]) -> None: ...
    def __call__(self) -> numpy.ndarray: ...

class Sampler:
    def __init__(self, *args, **kwargs) -> None: ...
    def reset(self, arg0, arg1: int) -> None: ...
    @property
    def d(self) -> int: ...

class Sobol(Sampler):
    def __init__(self, d: int) -> None: ...
    def __call__(self) -> numpy.ndarray: ...
    @property
    def cache(self) -> modcma.c_maes.cmaescpp.utils.CachedShuffleSequence: ...

class Uniform(Sampler):
    def __init__(self, d: int) -> None: ...
    def __call__(self) -> numpy.ndarray: ...
